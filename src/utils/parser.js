/**
 * @param {string} input
 */

// GENERATED BY CHATGPT AFTER A LONG TRIAL AND ERROR
function parsePathString(input) {
  const result = [];
  const stack = [];
  const tokens = input.trim().split(/\s+/);

  let currentBase = []; // stores the last known folder path

  let i = 0;
  while (i < tokens.length) {
    let token = tokens[i];

    if (token === "../" || token === "..") {
      if (currentBase.length > 0) currentBase.pop();
      i++;
      continue;
    }

    if (token === "&" || token === "+") {
      i++;
      continue;
    }

    // Clean up slashes
    token = token.replace(/^\/+|\/+$/g, "");
    if (!token) {
      i++;
      continue;
    }

    const parts = token.split("/");
    const isSingleFile = parts.length === 1 && parts[0].includes(".");

    if (parts.length > 1 || !isSingleFile) {
      // It's a nested path like "dir1/dir2/file.js"
      const tempStack = [...currentBase];

      for (const part of parts) {
        if (part === "..") {
          tempStack.pop();
        } else {
          tempStack.push(part);
        }
      }

      const last = tempStack[tempStack.length - 1];

      result.push({
        path: tempStack.join("/"),
        isDir: !last.includes("."),
      });

      // Update base
      if (!last.includes(".")) {
        currentBase = [...tempStack];
      } else {
        currentBase = [...tempStack.slice(0, -1)];
      }
    } else {
      // It's just a single file like style.css
      const fullPath = [...currentBase, token].join("/");

      result.push({
        path: fullPath,
        isDir: false,
      });
    }

    i++;
  }

  return result;
}

module.exports = {
  parsePathString,
};
